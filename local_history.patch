Index: core/src/de/tum/cit/ase/maze/Key.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/Key.java b/core/src/de/tum/cit/ase/maze/Key.java
new file mode 100644
--- /dev/null	(date 1704667156606)
+++ b/core/src/de/tum/cit/ase/maze/Key.java	(date 1704667156606)
@@ -0,0 +1,19 @@
+package de.tum.cit.ase.maze;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+
+public class Key extends MapObject{
+    private static final Texture backroundTexture = new Texture(Gdx.files.internal("basictiles.png"));
+    private static final Texture overlayTexture = new Texture(Gdx.files.internal("basictiles.png"));
+    // Assuming the y-coordinate for the second row is 16, since each tile is 16 pixels in height
+    private static final TextureRegion pathBackroundRegion = new TextureRegion(backroundTexture, 64, 16, 16, 16);
+    private static final TextureRegion pathOverlayTextureRegion = new TextureRegion(overlayTexture, 64, 112, 16, 16);
+
+    public void render(SpriteBatch spriteBatch, float x, float y, float tileSize) {
+        spriteBatch.draw(pathBackroundRegion, x, y, tileSize, tileSize);
+        spriteBatch.draw(pathOverlayTextureRegion, x, y, tileSize, tileSize);
+    }
+}
Index: core/src/de/tum/cit/ase/maze/Exit.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/Exit.java b/core/src/de/tum/cit/ase/maze/Exit.java
new file mode 100644
--- /dev/null	(date 1704667156567)
+++ b/core/src/de/tum/cit/ase/maze/Exit.java	(date 1704667156567)
@@ -0,0 +1,16 @@
+package de.tum.cit.ase.maze;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+
+public class Exit extends MapObject{
+    private static final Texture tilesTexture = new Texture(Gdx.files.internal("basictiles.png"));
+    // Assuming the y-coordinate for the second row is 16, since each tile is 16 pixels in height
+    private static final TextureRegion pathTextureRegion = new TextureRegion(tilesTexture, 32, 96, 16, 16);
+
+    public void render(SpriteBatch spriteBatch, float x, float y, float tileSize) {
+        spriteBatch.draw(pathTextureRegion, x, y, tileSize, tileSize);
+    }
+}
Index: core/src/de/tum/cit/ase/maze/Trap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/Trap.java b/core/src/de/tum/cit/ase/maze/Trap.java
new file mode 100644
--- /dev/null	(date 1704667156603)
+++ b/core/src/de/tum/cit/ase/maze/Trap.java	(date 1704667156603)
@@ -0,0 +1,19 @@
+package de.tum.cit.ase.maze;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+
+public class Trap extends MapObject{
+    private static final Texture backroundTexture = new Texture(Gdx.files.internal("basictiles.png"));
+    private static final Texture overlayTexture = new Texture(Gdx.files.internal("basictiles.png"));
+    // Assuming the y-coordinate for the second row is 16, since each tile is 16 pixels in height
+    private static final TextureRegion pathBackroundRegion = new TextureRegion(backroundTexture, 64, 16, 16, 16);
+    private static final TextureRegion pathOverlayTextureRegion = new TextureRegion(overlayTexture, 32, 32, 16, 16);
+
+    public void render(SpriteBatch spriteBatch, float x, float y, float tileSize) {
+        spriteBatch.draw(pathBackroundRegion, x, y, tileSize, tileSize);
+        spriteBatch.draw(pathOverlayTextureRegion, x, y, tileSize, tileSize);
+    }
+}
Index: core/src/de/tum/cit/ase/maze/Enemy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/Enemy.java b/core/src/de/tum/cit/ase/maze/Enemy.java
new file mode 100644
--- /dev/null	(date 1704667156604)
+++ b/core/src/de/tum/cit/ase/maze/Enemy.java	(date 1704667156604)
@@ -0,0 +1,185 @@
+package de.tum.cit.ase.maze;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.Animation;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.utils.Array;
+
+public class Enemy extends MapObject{
+        private float currentWindowX, currentWindowY;
+        private Animation<TextureRegion> characterDownAnimation;
+        private Animation<TextureRegion> characterUpAnimation;
+        private Animation<TextureRegion> characterRightAnimation;
+        private Animation<TextureRegion> characterLeftAnimation;
+
+        public TextureRegion getCharacterStandingUpTexture() {
+            return characterStandingUpTexture;
+        }
+
+        public TextureRegion getCharacterStandingDownTexture() {
+            return characterStandingDownTexture;
+        }
+
+        public TextureRegion getCharacterStandingLeftTexture() {
+            return characterStandingLeftTexture;
+        }
+
+        public TextureRegion getCharacterStandingRightTexture() {
+            return characterStandingRightTexture;
+        }
+
+        private TextureRegion characterStandingUpTexture;
+        private TextureRegion characterStandingDownTexture;
+        private TextureRegion characterStandingLeftTexture;
+        private TextureRegion characterStandingRightTexture;
+
+        private MapObject currentTile;
+        public Direction getDirection() {
+            return direction;
+        }
+
+        public void setDirection(Direction direction) {
+            this.direction = direction;
+        }
+
+        private Direction direction;
+        public int tileX;
+
+    public int getTileX() {
+        return tileX;
+    }
+
+    public void setTileX(int tileX) {
+        this.tileX = tileX;
+    }
+
+    public int getTileY() {
+        return tileY;
+    }
+
+    public void setTileY(int tileY) {
+        this.tileY = tileY;
+    }
+
+    public int tileY;
+
+        public Enemy(int tileX, int tileY) {
+            loadCharacterAnimations();
+            direction = Direction.DOWN;
+            this.tileX = tileX;
+            this.tileY = tileY;
+
+        }
+
+        public float getCurrentWindowX() {
+            return currentWindowX;
+        }
+
+        public float getCurrentWindowY() {
+            return currentWindowY;
+        }
+
+        public void setCurrentWindowX(float currentWindowX) {
+            this.currentWindowX = currentWindowX;
+        }
+
+        public void setCurrentWindowY(float currentWindowY) {
+            this.currentWindowY = currentWindowY;
+        }
+
+        private void loadCharacterAnimations() {
+            Texture walkSheet = new Texture(Gdx.files.internal("mobs.png"));
+            int frameWidth = 16;
+            int frameHeight = 16;
+            int animationFrames = 3;
+
+            characterDownAnimation = createAnimation(walkSheet, 144, 64, frameWidth, frameHeight, animationFrames);
+            characterRightAnimation = createAnimation(walkSheet, 144, 96, frameWidth, frameHeight, animationFrames);
+            characterUpAnimation = createAnimation(walkSheet,144, 112, frameWidth, frameHeight, animationFrames);
+            characterLeftAnimation = createAnimation(walkSheet, 144, 80, frameWidth, frameHeight, animationFrames);
+
+            characterStandingDownTexture = new TextureRegion(walkSheet, 160, 64, frameWidth, frameHeight);
+            characterStandingRightTexture = new TextureRegion(walkSheet, 160, 96, frameWidth, frameHeight);
+            characterStandingUpTexture = new TextureRegion(walkSheet, 160, 112, frameWidth, frameHeight);
+            characterStandingLeftTexture = new TextureRegion(walkSheet, 160, 80, frameWidth, frameHeight);
+        }
+
+        private Animation<TextureRegion> createAnimation(Texture sheet, int startY, int frameWidth, int frameHeight, int frameCount) {
+            Array<TextureRegion> frames = new Array<>(TextureRegion.class);
+            for (int i = 0; i < frameCount; i++) {
+                frames.add(new TextureRegion(sheet, i * frameWidth, startY, frameWidth, frameHeight));
+            }
+            return new Animation<>(0.1f, frames);
+        }
+
+    private Animation<TextureRegion> createAnimation(Texture sheet,int startX, int startY, int frameWidth, int frameHeight, int frameCount) {
+        Array<TextureRegion> frames = new Array<>(TextureRegion.class);
+        for (int i = 0; i < frameCount; i++) {
+            frames.add(new TextureRegion(sheet, (i * frameWidth)+startX, startY, frameWidth, frameHeight));
+        }
+        return new Animation<>(0.1f, frames);
+    }
+
+        // Getters for each animation
+        public Animation<TextureRegion> getCharacterDownAnimation() {
+            return characterDownAnimation;
+        }
+
+        public Animation<TextureRegion> getCharacterUpAnimation() {
+            return characterUpAnimation;
+        }
+
+        public Animation<TextureRegion> getCharacterRightAnimation() {
+            return characterRightAnimation;
+        }
+
+        public Animation<TextureRegion> getCharacterLeftAnimation() {
+            return characterLeftAnimation;
+        }
+
+        public void move(float speed) {
+            switch (this.direction) {
+                case UP:
+                    this.currentWindowY += speed ;
+                    break;
+                case DOWN:
+                    this.currentWindowY -= speed ;
+                    break;
+                case LEFT:
+                    this.currentWindowX -= speed ;
+                    break;
+                case RIGHT:
+                    this.currentWindowX += speed;
+                    break;
+                default:
+                    // No movement for standing directions
+                    break;
+            }
+        }
+
+
+        public MapObject getCurrentTile() {
+            return currentTile;
+        }
+
+
+        public void setCurrentTileFromCoords(GameMap gameMap, float tileSize){
+            int i = (int) ((getCurrentWindowX() + 32) / tileSize);
+            int j = (int) ((getCurrentWindowY() + 48)/ tileSize);
+            currentTile = gameMap.getStaticMapObjects()[j][i];
+        }
+
+        public void setWindowCordsFromTilet(float tileSize){
+            this.currentWindowX = this.tileX * tileSize;
+            this.currentWindowY = this.tileY * tileSize;
+        }
+
+    @Override
+    public void render(SpriteBatch spriteBatch, float x, float y, float tileSize) {
+        //TODO
+    }
+}
+
+
Index: core/src/de/tum/cit/ase/maze/GameHUD.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/GameHUD.java b/core/src/de/tum/cit/ase/maze/GameHUD.java
new file mode 100644
--- /dev/null	(date 1704667156579)
+++ b/core/src/de/tum/cit/ase/maze/GameHUD.java	(date 1704667156579)
@@ -0,0 +1,29 @@
+package de.tum.cit.ase.maze;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.scenes.scene2d.Stage;
+import com.badlogic.gdx.scenes.scene2d.ui.Label;
+import com.badlogic.gdx.utils.viewport.Viewport;
+
+
+
+public class GameHUD extends Stage {
+
+    private final Label livesLabel;
+    public GameHUD(Viewport viewport) {
+        super(viewport);
+        // Initialize your HUB components here
+        // Example: Add labels, images, or other actors
+        Label.LabelStyle labelStyle = new Label.LabelStyle(new BitmapFont(), Color.WHITE);
+        livesLabel = new Label("Lives: 5", labelStyle);
+        livesLabel.setPosition(10, viewport.getWorldHeight() - 20); // Adjust position as needed
+        addActor(livesLabel);
+    }
+
+    // Add methods to update the HUB components based on game data
+    public void updateScore(int newScore) {
+        // Update score label or other score-related components
+    }
+}
\ No newline at end of file
Index: core/src/de/tum/cit/ase/maze/EntryPoint.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/EntryPoint.java b/core/src/de/tum/cit/ase/maze/EntryPoint.java
new file mode 100644
--- /dev/null	(date 1704667156586)
+++ b/core/src/de/tum/cit/ase/maze/EntryPoint.java	(date 1704667156586)
@@ -0,0 +1,17 @@
+package de.tum.cit.ase.maze;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+
+public class EntryPoint extends MapObject{
+
+    private static final Texture tilesTexture = new Texture(Gdx.files.internal("basictiles.png"));
+    // Assuming the y-coordinate for the second row is 16, since each tile is 16 pixels in height
+    private static final TextureRegion pathTextureRegion = new TextureRegion(tilesTexture, 0, 96, 16, 16);
+
+    public void render(SpriteBatch spriteBatch, float x, float y, float tileSize) {
+        spriteBatch.draw(pathTextureRegion, x, y, tileSize, tileSize);
+    }
+}
Index: core/src/de/tum/cit/ase/maze/VictoryScreen.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/VictoryScreen.java b/core/src/de/tum/cit/ase/maze/VictoryScreen.java
new file mode 100644
--- /dev/null	(date 1704667156573)
+++ b/core/src/de/tum/cit/ase/maze/VictoryScreen.java	(date 1704667156573)
@@ -0,0 +1,166 @@
+package de.tum.cit.ase.maze;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.Screen;
+import com.badlogic.gdx.audio.Music;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.OrthographicCamera;
+import com.badlogic.gdx.scenes.scene2d.Actor;
+import com.badlogic.gdx.scenes.scene2d.Stage;
+import com.badlogic.gdx.scenes.scene2d.actions.Actions;
+import com.badlogic.gdx.scenes.scene2d.ui.Label;
+import com.badlogic.gdx.scenes.scene2d.ui.Table;
+import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
+import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
+import com.badlogic.gdx.utils.viewport.ScreenViewport;
+import com.badlogic.gdx.utils.viewport.Viewport;
+
+/**
+ * The VictoryScreen class is responsible for displaying the victory screen in the game.
+ * It extends the LibGDX Screen class and sets up the UI components for the screen.
+ */
+public class VictoryScreen implements Screen {
+
+    private final Stage stage;
+    private Music victoryMusic;
+
+    /**
+     * Constructor for VictoryScreen. Sets up the camera, viewport, stage, and UI elements.
+     *
+     * @param game The main game class, used to access global resources and methods.
+     */
+    public VictoryScreen(MazeRunnerGame game) {
+        this.victoryMusic = Gdx.audio.newMusic(Gdx.files.internal("victory2.wav"));
+        victoryMusic.setVolume(2.0f);
+        victoryMusic.setLooping(false);
+        victoryMusic.play();
+
+        var camera = new OrthographicCamera();
+        camera.zoom = 1.5f;
+
+        Viewport viewport = new ScreenViewport(camera);
+        stage = new Stage(viewport, game.getSpriteBatch());
+
+        Table table = new Table();
+        table.setFillParent(true);
+
+        Label victory = new Label("VICTORY!", game.getSkin(), "title");
+        victory.setColor(Color.YELLOW);
+        victory.addAction(Actions.parallel(
+                Actions.moveBy(200, 0, 1.0f),
+                Actions.color(new Color(1, 0.5f, 0, 1), 1.0f)
+        ));
+        victory.addAction(
+                Actions.forever(
+                        Actions.sequence(
+                                Actions.parallel(
+                                        Actions.moveBy(-400, 0, 2.0f),
+                                        Actions.color(Color.YELLOW, 1.0f)
+                                ),
+                                Actions.parallel(
+                                        Actions.moveBy(400, 0, 2.0f),
+                                        Actions.color(new Color(1, 0.5f, 0, 1), 1.0f)
+                                )
+                        )
+                )
+        );
+
+        table.add(victory).padBottom(100).row();
+        stage.addActor(table);
+
+        table.add(new Label("You successfully exit the maze", game.getSkin(), "title")).padBottom(80).row();
+
+        TextButton continueButton = new TextButton("Next Level", game.getSkin());
+        table.add(continueButton).width(300).row();
+        continueButton.addListener(new ChangeListener() {
+            @Override
+            public void changed(ChangeEvent event, Actor actor) {
+                clickSound();
+            }
+        });
+
+        TextButton startNewGameButton = new TextButton("Play Again", game.getSkin());
+        table.add(startNewGameButton).width(300).row();
+        startNewGameButton.addListener(new ChangeListener() {
+            @Override
+            public void changed(ChangeEvent event, Actor actor) {
+                clickSound();
+                buttonStartNewGameFadeAway(startNewGameButton, game);
+            }
+        });
+
+        TextButton exitButton = new TextButton("Back to Menu", game.getSkin());
+        table.add(exitButton).width(300).row();
+        exitButton.addListener(new ChangeListener() {
+            @Override
+            public void changed(ChangeEvent event, Actor actor) {
+                clickSound();
+                exitButtonFadeAway(exitButton, game);
+            }
+        });
+    }
+    private void buttonStartNewGameFadeAway(TextButton textButton, MazeRunnerGame game) {
+        textButton.addAction(Actions.sequence(
+                Actions.fadeOut(0.5f),
+                Actions.run(() -> {
+                    game.dispose();
+                    game.create();
+                    game.goToGame();
+                })
+        ));
+    }
+
+    private void exitButtonFadeAway(TextButton exitButton, MazeRunnerGame game) {
+        exitButton.addAction(Actions.sequence(
+                Actions.fadeOut(0.5f),
+                Actions.run(() -> {
+                    game.dispose();
+                    game.create();
+                    game.goToMenu();
+                })
+        ));
+    }
+    private void clickSound() {
+        Music clickMusic = Gdx.audio.newMusic(Gdx.files.internal("click_sound.mp3"));
+        clickMusic.setVolume(2.5f);
+        clickMusic.setLooping(false);
+        clickMusic.play();
+    }
+
+
+    @Override
+    public void render(float delta) {
+        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
+        stage.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));
+        stage.draw();
+    }
+
+    @Override
+    public void resize(int width, int height) {
+        stage.getViewport().update(width, height, true);
+    }
+
+    @Override
+    public void dispose() {
+        stage.dispose();
+        victoryMusic.dispose();
+    }
+
+    @Override
+    public void show() {
+        Gdx.input.setInputProcessor(stage);
+    }
+
+    @Override
+    public void pause() {
+    }
+
+    public void resume() {
+    }
+
+    @Override
+    public void hide() {
+    }
+}
+
Index: core/src/de/tum/cit/ase/maze/GameScreen_structure.puml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/GameScreen_structure.puml b/core/src/de/tum/cit/ase/maze/GameScreen_structure.puml
new file mode 100644
--- /dev/null	(date 1704667156601)
+++ b/core/src/de/tum/cit/ase/maze/GameScreen_structure.puml	(date 1704667156601)
@@ -0,0 +1,337 @@
+@startuml
+
+/' diagram meta data start
+config=StructureConfiguration;
+{
+  "projectClassification": {
+    "searchMode": "OpenProject", // OpenProject, AllProjects
+    "includedProjects": "",
+    "pathEndKeywords": "*.impl",
+    "isClientPath": "",
+    "isClientName": "",
+    "isTestPath": "",
+    "isTestName": "",
+    "isMappingPath": "",
+    "isMappingName": "",
+    "isDataAccessPath": "",
+    "isDataAccessName": "",
+    "isDataStructurePath": "",
+    "isDataStructureName": "",
+    "isInterfaceStructuresPath": "",
+    "isInterfaceStructuresName": "",
+    "isEntryPointPath": "",
+    "isEntryPointName": "",
+    "treatFinalFieldsAsMandatory": false
+  },
+  "graphRestriction": {
+    "classPackageExcludeFilter": "",
+    "classPackageIncludeFilter": "",
+    "classNameExcludeFilter": "",
+    "classNameIncludeFilter": "",
+    "methodNameExcludeFilter": "",
+    "methodNameIncludeFilter": "",
+    "removeByInheritance": "", // inheritance/annotation based filtering is done in a second step
+    "removeByAnnotation": "",
+    "removeByClassPackage": "", // cleanup the graph after inheritance/annotation based filtering is done
+    "removeByClassName": "",
+    "cutMappings": false,
+    "cutEnum": false,
+    "cutTests": true,
+    "cutClient": true,
+    "cutDataAccess": false,
+    "cutInterfaceStructures": false,
+    "cutDataStructures": false,
+    "cutGetterAndSetter": false,
+    "cutConstructors": false
+  },
+  "graphTraversal": {
+    "forwardDepth": 3,
+    "backwardDepth": 3,
+    "classPackageExcludeFilter": "",
+    "classPackageIncludeFilter": "",
+    "classNameExcludeFilter": "",
+    "classNameIncludeFilter": "",
+    "methodNameExcludeFilter": "",
+    "methodNameIncludeFilter": "",
+    "hideMappings": false,
+    "hideDataStructures": false,
+    "hidePrivateMethods": true,
+    "hideInterfaceCalls": true, // indirection: implementation -> interface (is hidden) -> implementation
+    "onlyShowApplicationEntryPoints": false, // root node is included
+    "useMethodCallsForStructureDiagram": "ForwardOnly" // ForwardOnly, BothDirections, No
+  },
+  "details": {
+    "aggregation": "GroupByClass", // ByClass, GroupByClass, None
+    "showClassGenericTypes": true,
+    "showMethods": true,
+    "showMethodParameterNames": true,
+    "showMethodParameterTypes": true,
+    "showMethodReturnType": true,
+    "showPackageLevels": 2,
+    "showDetailedClassStructure": true
+  },
+  "rootClass": "de.tum.cit.ase.maze.GameScreen",
+  "extensionCallbackMethod": "" // qualified.class.name#methodName - signature: public static String method(String)
+}
+diagram meta data end '/
+
+
+
+digraph g {
+    rankdir="TB"
+    splines=polyline
+    
+
+'nodes 
+subgraph cluster_115212 { 
+   	label=tum
+	labeljust=l
+	fillcolor="#ececec"
+	style=filled
+   
+   subgraph cluster_972012052 { 
+   	label=cit
+	labeljust=l
+	fillcolor="#d8d8d8"
+	style=filled
+   
+   Direction521980439[
+	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
+<TR><TD ALIGN="LEFT" >(E)Direction</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >+   DOWN: Direction [1]</TD></TR>
+<TR><TD ALIGN="LEFT" >+   LEFT: Direction [1]</TD></TR>
+<TR><TD ALIGN="LEFT" >+   RIGHT: Direction [1]</TD></TR>
+<TR><TD ALIGN="LEFT" >+   STANDINGDOWN: Direction [1]</TD></TR>
+<TR><TD ALIGN="LEFT" >+   STANDINGLEFT: Direction [1]</TD></TR>
+<TR><TD ALIGN="LEFT" >+   STANDINGRIGHT: Direction [1]</TD></TR>
+<TR><TD ALIGN="LEFT" >+   STANDINGUP: Direction [1]</TD></TR>
+<TR><TD ALIGN="LEFT" >+   UP: Direction [1]</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >+ valueOf(name: String): Direction</TD></TR>
+<TR><TD ALIGN="LEFT" >+ values(): Direction[]</TD></TR>
+</TABLE>>
+	style=filled
+	margin=0
+	shape=plaintext
+	fillcolor="#DCFBD5"
+];
+
+GameEngine521980439[
+	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
+<TR><TD ALIGN="LEFT" >(C)GameEngine</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >-   player: Player [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   staticGameMap: GameMap [0..1]</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >+ GameEngine()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getPlayer(): Player</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getStaticGameMap(): GameMap</TD></TR>
+<TR><TD ALIGN="LEFT" >- loadMap()</TD></TR>
+</TABLE>>
+	style=filled
+	margin=0
+	shape=plaintext
+	fillcolor="#FFFFFF"
+];
+
+GameMap521980439[
+	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
+<TR><TD ALIGN="LEFT" >(C)GameMap</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >-   staticMapObjects: MapObject[][] [0..*]</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >+ GameMap()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getStaticMapObjects(): MapObject[][]</TD></TR>
+<TR><TD ALIGN="LEFT" >+ loadMap(filePath: String)</TD></TR>
+</TABLE>>
+	style=filled
+	margin=0
+	shape=plaintext
+	fillcolor="#FFFFFF"
+];
+
+GameScreen521980439[
+	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
+<TR><TD ALIGN="LEFT" >(C)GameScreen</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >-   camera: OrthographicCamera [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   font: BitmapFont [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   game: MazeRunnerGame [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   playerSpeed: float [1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   sinusInput: float [1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   tileSize: float [1]</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >+ GameScreen(game: MazeRunnerGame)</TD></TR>
+<TR><TD ALIGN="LEFT" >+ dispose()</TD></TR>
+<TR><TD ALIGN="LEFT" >- getStandingDirection(currentDirection: Direction): Direction</TD></TR>
+<TR><TD ALIGN="LEFT" >+ hide()</TD></TR>
+<TR><TD ALIGN="LEFT" >- isPlayerAtEdge(): boolean</TD></TR>
+<TR><TD ALIGN="LEFT" >+ pause()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ render(delta: float)</TD></TR>
+<TR><TD ALIGN="LEFT" >+ renderMap()</TD></TR>
+<TR><TD ALIGN="LEFT" >- renderPlayer()</TD></TR>
+<TR><TD ALIGN="LEFT" >- renderStandingPlayer()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ resize(width: int, height: int)</TD></TR>
+<TR><TD ALIGN="LEFT" >+ resume()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ show()</TD></TR>
+<TR><TD ALIGN="LEFT" >- updateCameraPosition()</TD></TR>
+</TABLE>>
+	style=filled
+	margin=0
+	shape=plaintext
+	fillcolor="#FFFFFF"
+];
+
+MapObject521980439[
+	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
+<TR><TD ALIGN="LEFT" >(C)MapObject</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >+ render(spriteBatch: SpriteBatch, x: float, y: float, tileSize: float)</TD></TR>
+</TABLE>>
+	style=filled
+	margin=0
+	shape=plaintext
+	fillcolor="#FFFFFF"
+];
+
+MazeRunnerGame521980439[
+	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
+<TR><TD ALIGN="LEFT" >(C)MazeRunnerGame</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >-   characterDownAnimation: Animation&lt;TextureRegion&gt; [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   gameEngine: GameEngine [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   gameScreen: GameScreen [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   menuScreen: MenuScreen [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   skin: Skin [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   spriteBatch: SpriteBatch [0..1]</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >+ MazeRunnerGame(fileChooser: NativeFileChooser)</TD></TR>
+<TR><TD ALIGN="LEFT" >+ create()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ dispose()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getCharacterDownAnimation(): Animation&lt;TextureRegion&gt;</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getGameEngine(): GameEngine</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getSkin(): Skin</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getSpriteBatch(): SpriteBatch</TD></TR>
+<TR><TD ALIGN="LEFT" >+ goToGame()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ goToMenu()</TD></TR>
+</TABLE>>
+	style=filled
+	margin=0
+	shape=plaintext
+	fillcolor="#FFFFFF"
+];
+
+MenuScreen521980439[
+	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
+<TR><TD ALIGN="LEFT" >(C)MenuScreen</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >-   stage: Stage [0..1]</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >+ MenuScreen(game: MazeRunnerGame)</TD></TR>
+<TR><TD ALIGN="LEFT" >+ dispose()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ hide()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ pause()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ render(delta: float)</TD></TR>
+<TR><TD ALIGN="LEFT" >+ resize(width: int, height: int)</TD></TR>
+<TR><TD ALIGN="LEFT" >+ resume()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ show()</TD></TR>
+</TABLE>>
+	style=filled
+	margin=0
+	shape=plaintext
+	fillcolor="#FFFFFF"
+];
+
+Path521980439[
+	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
+<TR><TD ALIGN="LEFT" >(C)Path</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >+ render(spriteBatch: SpriteBatch, x: float, y: float, tileSize: float)</TD></TR>
+</TABLE>>
+	style=filled
+	margin=0
+	shape=plaintext
+	fillcolor="#FFFFFF"
+];
+
+Player521980439[
+	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
+<TR><TD ALIGN="LEFT" >(C)Player</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >-   characterDownAnimation: Animation&lt;TextureRegion&gt; [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   characterLeftAnimation: Animation&lt;TextureRegion&gt; [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   characterRightAnimation: Animation&lt;TextureRegion&gt; [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   characterStandingDownTexture: TextureRegion [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   characterStandingLeftTexture: TextureRegion [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   characterStandingRightTexture: TextureRegion [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   characterStandingUpTexture: TextureRegion [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   characterUpAnimation: Animation&lt;TextureRegion&gt; [0..1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   currentWindowX: float [1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   currentWindowY: float [1]</TD></TR>
+<TR><TD ALIGN="LEFT" >-   direction: Direction [0..1]</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >+ Player()</TD></TR>
+<TR><TD ALIGN="LEFT" >- createAnimation(sheet: Texture, startY: int, frameWidth: int, frameHeight: int, frameCount: int): Animation&lt;TextureRegion&gt;</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getCharacterDownAnimation(): Animation&lt;TextureRegion&gt;</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getCharacterLeftAnimation(): Animation&lt;TextureRegion&gt;</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getCharacterRightAnimation(): Animation&lt;TextureRegion&gt;</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getCharacterStandingDownTexture(): TextureRegion</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getCharacterStandingLeftTexture(): TextureRegion</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getCharacterStandingRightTexture(): TextureRegion</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getCharacterStandingUpTexture(): TextureRegion</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getCharacterUpAnimation(): Animation&lt;TextureRegion&gt;</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getCurrentWindowX(): float</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getCurrentWindowY(): float</TD></TR>
+<TR><TD ALIGN="LEFT" >+ getDirection(): Direction</TD></TR>
+<TR><TD ALIGN="LEFT" >- loadCharacterAnimations()</TD></TR>
+<TR><TD ALIGN="LEFT" >+ move(speed: float)</TD></TR>
+<TR><TD ALIGN="LEFT" >+ setCurrentWindowX(currentWindowX: float)</TD></TR>
+<TR><TD ALIGN="LEFT" >+ setCurrentWindowY(currentWindowY: float)</TD></TR>
+<TR><TD ALIGN="LEFT" >+ setDirection(direction: Direction)</TD></TR>
+</TABLE>>
+	style=filled
+	margin=0
+	shape=plaintext
+	fillcolor="#FFFFFF"
+];
+
+Wall521980439[
+	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
+<TR><TD ALIGN="LEFT" >(C)Wall</TD></TR>
+<HR/>
+<TR><TD ALIGN="LEFT" >+ render(spriteBatch: SpriteBatch, x: float, y: float, tileSize: float)</TD></TR>
+</TABLE>>
+	style=filled
+	margin=0
+	shape=plaintext
+	fillcolor="#FFFFFF"
+];
+} 
+} 
+
+'edges    
+GameEngine521980439 -> GameMap521980439[label="staticGameMap
+[0..1]"];
+GameEngine521980439 -> Player521980439[label="player
+[0..1]"];
+GameMap521980439 -> MapObject521980439[label="staticMapObjects
+[0..*]"];
+GameScreen521980439 -> GameMap521980439[label="renderMap() -> getStaticMapObjects()"];
+GameScreen521980439 -> MapObject521980439[label="renderMap() -> render()"];
+GameScreen521980439 -> MazeRunnerGame521980439[label="game
+[0..1]"];
+MapObject521980439 -> Path521980439[arrowhead=none, arrowtail=empty, dir=both];
+MapObject521980439 -> Wall521980439[arrowhead=none, arrowtail=empty, dir=both];
+MazeRunnerGame521980439 -> GameEngine521980439[label="gameEngine
+[0..1]"];
+MazeRunnerGame521980439 -> GameScreen521980439[label="gameScreen
+[0..1]"];
+MazeRunnerGame521980439 -> MenuScreen521980439[label="menuScreen
+[0..1]"];
+MazeRunnerGame521980439 -> Player521980439[label="getCharacterDownAnimation() -> getCharacterDownAnimation()"];
+Player521980439 -> Direction521980439[label="direction
+[0..1]"];
+    
+}
+@enduml
\ No newline at end of file
Index: core/src/de/tum/cit/ase/maze/Player.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/Player.java b/core/src/de/tum/cit/ase/maze/Player.java
--- a/core/src/de/tum/cit/ase/maze/Player.java	
+++ b/core/src/de/tum/cit/ase/maze/Player.java	(date 1704667156640)
@@ -1,8 +1,10 @@
 package de.tum.cit.ase.maze;
 
 import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.OrthographicCamera;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.g2d.Animation;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.utils.Array;
 
@@ -13,17 +15,6 @@
     private Animation<TextureRegion> characterUpAnimation;
     private Animation<TextureRegion> characterRightAnimation;
     private Animation<TextureRegion> characterLeftAnimation;
-    private TextureRegion characterStandingUpTexture;
-    private TextureRegion characterStandingDownTexture;
-    private TextureRegion characterStandingLeftTexture;
-    private TextureRegion characterStandingRightTexture;
-    private MapObject currentTile;
-    private Direction direction;
-
-    public Player() {
-        loadCharacterAnimations();
-        direction = Direction.STANDINGUP;
-    }
 
     public TextureRegion getCharacterStandingUpTexture() {
         return characterStandingUpTexture;
@@ -41,6 +32,12 @@
         return characterStandingRightTexture;
     }
 
+    private TextureRegion characterStandingUpTexture;
+    private TextureRegion characterStandingDownTexture;
+    private TextureRegion characterStandingLeftTexture;
+    private TextureRegion characterStandingRightTexture;
+
+    private MapObject currentTile;
     public Direction getDirection() {
         return direction;
     }
@@ -49,18 +46,25 @@
         this.direction = direction;
     }
 
+    private Direction direction;
+
+    public Player() {
+        loadCharacterAnimations();
+        direction = Direction.STANDINGUP;
+    }
+
     public float getCurrentWindowX() {
         return currentWindowX;
     }
 
+    public float getCurrentWindowY() {
+        return currentWindowY;
+    }
+
     public void setCurrentWindowX(float currentWindowX) {
         this.currentWindowX = currentWindowX;
     }
 
-    public float getCurrentWindowY() {
-        return currentWindowY;
-    }
-
     public void setCurrentWindowY(float currentWindowY) {
         this.currentWindowY = currentWindowY;
     }
@@ -110,13 +114,13 @@
     public void move(float speed) {
         switch (this.direction) {
             case UP:
-                this.currentWindowY += speed;
+                this.currentWindowY += speed ;
                 break;
             case DOWN:
-                this.currentWindowY -= speed;
+                this.currentWindowY -= speed ;
                 break;
             case LEFT:
-                this.currentWindowX -= speed;
+                this.currentWindowX -= speed ;
                 break;
             case RIGHT:
                 this.currentWindowX += speed;
@@ -133,57 +137,10 @@
     }
 
 
-    public void setCurrentTileFromCoords(GameMap gameMap, float tileSize) {
+    public void setCurrentTileFromCoords(GameMap gameMap, float tileSize){
         int i = (int) ((getCurrentWindowX() + 32) / tileSize);
-        int j = (int) ((getCurrentWindowY() + 48) / tileSize);
+        int j = (int) ((getCurrentWindowY() + 48)/ tileSize);
         currentTile = gameMap.getStaticMapObjects()[j][i];
     }
 
-    public float getOffsetWindowX(float tileSize, Personality personality) {
-        switch (getDirection()) {
-            case RIGHT:
-            case STANDINGRIGHT:
-                if (personality == Personality.INFRONT) {
-                    return currentWindowX + 2 * tileSize;
-                } else if (personality == Personality.FOLLOWER) {
-                    return currentWindowX - 1 * tileSize;
-                } else {
-                    return getCurrentWindowX();
-                }
-            case STANDINGLEFT:
-            case LEFT:
-                if (personality == Personality.INFRONT) {
-                    return currentWindowX - 2 * tileSize;
-                } else if (personality == Personality.FOLLOWER) {
-                    return currentWindowX + 1 * tileSize;
-                } else {
-                    return getCurrentWindowX();
-                }
-        }
-        return getCurrentWindowX();
-    }
-
-    public float getOffsetWindowY(float tileSize, Personality personality) {
-        switch (getDirection()) {
-            case UP:
-            case STANDINGUP:
-                if (personality == Personality.INFRONT) {
-                    return currentWindowY + 2 * tileSize;
-                } else if (personality == Personality.FOLLOWER) {
-                    return currentWindowY - 1 * tileSize;
-                } else {
-                    return getCurrentWindowY();
-                }
-            case DOWN:
-            case STANDINGDOWN:
-                if (personality == Personality.INFRONT) {
-                    return currentWindowY - 2 * tileSize;
-                } else if (personality == Personality.FOLLOWER) {
-                    return currentWindowY + 1 * tileSize;
-                } else {
-                    return getCurrentWindowY();
-                }
-        }
-        return getCurrentWindowY();
-    }
 }
Index: core/src/de/tum/cit/ase/maze/GameMap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/GameMap.java b/core/src/de/tum/cit/ase/maze/GameMap.java
--- a/core/src/de/tum/cit/ase/maze/GameMap.java	
+++ b/core/src/de/tum/cit/ase/maze/GameMap.java	(date 1704667156635)
@@ -1,8 +1,4 @@
 package de.tum.cit.ase.maze;
-
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -13,11 +9,6 @@
     private List<Enemy> enemies;
     private int keysLeft;
 
-    private List<EntryPoint> entryPoints;
-
-    public GameMap() {
-    }
-
     public List<Enemy> getEnemies() {
         return enemies;
     }
@@ -26,60 +17,70 @@
         this.enemies = enemies;
     }
 
+    private List<Enemy> enemies;
+    private int keysLeft;
+
+    public GameMap() {
+    }
 
     // Loads Game Map into the staticMapObjects
-    public void loadMap(String filePath) {
+    public void loadMap(String filePath){
         enemies = new ArrayList<>();
         Properties prop = new Properties();
         int[][] intArray;
         int maxRow = 0, maxCol = 0;
-
+        keysLeft = 0;
         try (InputStream input = new FileInputStream(filePath)) {
             prop.load(input);
 
-            // First pass to find the size of the array
-            for (String key : prop.stringPropertyNames()) {
-                String[] parts = key.split(",");
-                int row = Integer.parseInt(parts[0]);
-                int col = Integer.parseInt(parts[1]);
-                maxRow = Math.max(maxRow, row);
-                maxCol = Math.max(maxCol, col);
-            }
+                Iterator var7;
+                String key;
+                String[] parts;
+                int row;
+                int col;
+                for(var7 = prop.stringPropertyNames().iterator(); var7.hasNext(); maxCol = Math.max(maxCol, col)) {
+                    key = (String)var7.next();
+                    parts = key.split(",");
+                    row = Integer.parseInt(parts[0]);
+                    col = Integer.parseInt(parts[1]);
+                    maxRow = Math.max(maxRow, row);
+                }
 
-            // Initialize the intArray with -1
-            intArray = new int[maxRow + 1][maxCol + 1]; // +1 because arrays are 0-indexed
-            for (int[] row : intArray) {
-                Arrays.fill(row, -1);
-            }
+                int[][] intArray = new int[maxRow + 1][maxCol + 1];
+                int[][] var15 = intArray;
+                int j = intArray.length;
+
+                for(int var18 = 0; var18 < j; ++var18) {
+                    int[] row = var15[var18];
+                    Arrays.fill(row, -1);
+                }
 
-            // Second pass to fill the array
-            for (String key : prop.stringPropertyNames()) {
-                String[] parts = key.split(",");
-                int row = Integer.parseInt(parts[0]);
-                int col = Integer.parseInt(parts[1]);
-                intArray[row][col] = Integer.parseInt(prop.getProperty(key));
-            }
-            // Example to print the array
-            for (int i = 0; i < intArray.length; i++) {
-                for (int j = 0; j < intArray[i].length; j++) {
-                    System.out.print(intArray[i][j] + " ");
-                }
-                System.out.println();
-            }
+                for(var7 = prop.stringPropertyNames().iterator(); var7.hasNext(); intArray[row][col] = Integer.parseInt(prop.getProperty(key))) {
+                    key = (String)var7.next();
+                    parts = key.split(",");
+                    row = Integer.parseInt(parts[0]);
+                    col = Integer.parseInt(parts[1]);
+                }
+
+                int i;
+                for(i = 0; i < intArray.length; ++i) {
+                    for(j = 0; j < intArray[i].length; ++j) {
+                        System.out.print(intArray[i][j] + " ");
+                    }
+
+                    System.out.println();
+                }
 
-            staticMapObjects = new MapObject[maxRow + 1][maxCol + 1];
+                this.staticMapObjects = new MapObject[maxRow + 1][maxCol + 1];
 
             for (int i = 0; i < intArray.length; i++) {
                 for (int j = 0; j < intArray[i].length; j++) {
-                    switch (intArray[i][j]) {
+                    switch (intArray[i][j]){
                         case 0:
                             staticMapObjects[i][j] = new Wall();
                             break;
                         case 1:
                             staticMapObjects[i][j] = new EntryPoint();
-                            entryPoints.add((EntryPoint) staticMapObjects[i][j]);
-                            ((EntryPoint) staticMapObjects[i][j]).setX(j);
-                            ((EntryPoint) staticMapObjects[i][j]).setY(i);
                             break;
                         case 2:
                             staticMapObjects[i][j] = new Exit();
@@ -89,8 +90,8 @@
                             break;
                         case 4:
                             staticMapObjects[i][j] = new Path();
-                            enemies.add(new Enemy(i, j));
-                            enemies.get(enemies.size() - 1).setWindowCordsFromTilet(GameScreen.tileSize);
+                            enemies.add(new Enemy(i,j));
+
                             break;
                         case 5:
                             staticMapObjects[i][j] = new Key();
@@ -101,47 +102,52 @@
                             break;
                     }
                 }
+            } catch (Throwable var13) {
+                try {
+                    input.close();
+                } catch (Throwable var12) {
+                    var13.addSuppressed(var12);
+                }
+
+                throw var13;
             }
 
-        } catch (IOException ex) {
-            ex.printStackTrace();
+            input.close();
+        } catch (IOException var14) {
+            var14.printStackTrace();
         }
+
     }
 
     public MapObject[][] getStaticMapObjects() {
-        return staticMapObjects;
+        return this.staticMapObjects;
     }
 
-    public float getMapWidth() {
+    public float getMapWidth(){
         return staticMapObjects[0].length;
     }
-
-    public float getMapHeight() {
+    public float getMapHeight(){
         return staticMapObjects.length;
     }
 
 
-    public MapObject getTile(float x, float y, float tileSize) {
+    public MapObject getTile(float x, float y, float tileSize){
         int i = (int) ((x) / tileSize);
-        int j = (int) ((y) / tileSize);
+        int j = (int) ((y)/ tileSize);
         return getStaticMapObjects()[j][i];
     }
 
-    public int getKeysLeft() {
+    public int getKeysLeft(){
         return keysLeft;
     }
 
-    public void removeKey(float x, float y, float tileSize) {
+    public void removeKey(float x, float y, float tileSize){
         int i = (int) ((x) / tileSize);
-        int j = (int) ((y) / tileSize);
+        int j = (int) ((y)/ tileSize);
         staticMapObjects[j][i] = new Path();
         keysLeft--;
-        if (keysLeft < 0) {
+        if(keysLeft < 0){
             keysLeft = 0;
         }
     }
-
-    public List<EntryPoint> getEntryPoints() {
-        return entryPoints;
-    }
 }
Index: core/src/de/tum/cit/ase/maze/GameEngine.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/GameEngine.java b/core/src/de/tum/cit/ase/maze/GameEngine.java
--- a/core/src/de/tum/cit/ase/maze/GameEngine.java	
+++ b/core/src/de/tum/cit/ase/maze/GameEngine.java	(date 1704667156632)
@@ -1,27 +1,38 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by FernFlower decompiler)
+//
+
 package de.tum.cit.ase.maze;
 
-import java.io.Serializable;
-
 public class GameEngine {
     private GameMap staticGameMap;
     private Player player;
 
+    public Player getPlayer() {
+        return this.player;
+    }
+
+    public void setPlayer(Player player) {
+        this.player = player;
+    }
+
+    private Player player;
+
 
     public GameEngine() {
         System.out.println("Loading Game Engine");
         System.out.println("Current working directory: " + System.getProperty("user.dir"));
-
-        player = new Player();
-        staticGameMap = new GameMap();
-        loadMap();
+        System.out.println("Game engine select:" + game.selectedMap);
+        this.player = new Player();
+        this.staticGameMap = new GameMap();
+        this.staticGameMap.loadMap(game.selectedMap);
     }
 
-    // Needs to be changed later with Map-Selection Menu
-    private void loadMap(){
-        staticGameMap.loadMap("maps/level-1.properties");
+    public void loadMap() {
     }
 
     public GameMap getStaticGameMap() {
-        return staticGameMap;
+        return this.staticGameMap;
     }
 }
Index: core/src/de/tum/cit/ase/maze/GameScreen.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/GameScreen.java b/core/src/de/tum/cit/ase/maze/GameScreen.java
--- a/core/src/de/tum/cit/ase/maze/GameScreen.java	
+++ b/core/src/de/tum/cit/ase/maze/GameScreen.java	(date 1704667156627)
@@ -10,10 +10,19 @@
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.utils.ScreenUtils;
 
-import java.io.Serializable;
 
 import static de.tum.cit.ase.maze.Direction.*;
 
+
+import com.badlogic.gdx.ScreenAdapter;
+//Test
+import java.io.Serializable;
+import java.io.ObjectOutputStream;
+import java.io.IOException;
+import java.io.FileOutputStream;
+import java.io.ObjectInputStream;
+import java.io.FileInputStream;
+
 /**
  * The GameScreen class is responsible for rendering the gameplay screen.
  * It handles the game logic and rendering of the game elements.
@@ -25,19 +34,36 @@
     static final int GAME_PAUSED = 2;
     static final int GAME_LEVEL_END = 3;
     static final int GAME_OVER = 4;
+
+    int gameState;
+
+    public int getGameState() {
+        return gameState;
+    }
+
+    public void setGameState(int gameState) {
+        this.gameState = gameState;
+    }
+
     //JODIE TRY
-    static final float tileSize = 80;
-    static final float enemySpeed = 1;
+
     private final MazeRunnerGame game;
     private final OrthographicCamera camera;
     private final BitmapFont font;
-    int gameState;
-    float centerPlayerXOffset = 32;
-    float centerPlayerYOffset = 48;
+
+
     private float sinusInput = 0f;
+
+    private final float tileSize = 80;
+
+
     private float playerSpeed = 3;
-    private float mapMaxX, mapMaxY;
-    private boolean gameStart;
+
+    private  float mapMaxX, mapMaxY;
+
+    float centerPlayerXOffset = 32;
+    float centerPlayerYOffset = 48;
+
 
     /**
      * Constructor for GameScreen. Sets up the camera and font.
@@ -47,6 +73,8 @@
     public GameScreen(MazeRunnerGame game) {
         this.game = game;
 
+        gameState = GAME_RUNNING;
+
         // Create and configure the camera for the game view
         camera = new OrthographicCamera();
         camera.setToOrtho(false);
@@ -56,47 +84,21 @@
         font = game.getSkin().getFont("font");
 
         //Create Player
-        float x = this.game.getGameEngine().getStaticGameMap().getEntryPoints().get(0).getX();
-        float y = this.game.getGameEngine().getStaticGameMap().getEntryPoints().get(0).getY();
-
-        game.getGameEngine().getPlayer().setCurrentWindowX(x * tileSize + 16);
-        game.getGameEngine().getPlayer().setCurrentWindowY(y * tileSize + 16);
-        game.getGameEngine().getPlayer().setDirection(DOWN);
-
-        intialCameraPositon();
-
-        gameStart = true;
-
+        game.getGameEngine().getPlayer().setCurrentWindowX(camera.viewportWidth / 2);
+        game.getGameEngine().getPlayer().setCurrentWindowY(camera.viewportHeight / 2);
         game.setGameScreen(this);
-    }
 
-    private void intialCameraPositon() {
-        System.out.println("");
-        game.getGameEngine().getPlayer().setCurrentTileFromCoords(game.getGameEngine().getStaticGameMap(), tileSize);
 
-        camera.position.x = game.getGameEngine().getPlayer().getCurrentWindowX();
-        camera.position.y = game.getGameEngine().getPlayer().getCurrentWindowY();
 
-        camera.update();
-        System.out.println("Set initial Camera to: " + camera.position.x + " " + camera.position.y);
-        System.out.println("Player at " + game.getGameEngine().getPlayer().getCurrentWindowX() + " " + game.getGameEngine().getPlayer().getCurrentWindowY());
     }
 
-
-    public int getGameState() {
-        return gameState;
-    }
-
-    public void setGameState(int gameState) {
-        this.gameState = gameState;
-    }
 
     // Screen interface methods with necessary functionality
     @Override
     public void render(float delta) {
-
         // Check for escape key press to go back to the menu
         if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
+            //this.gameState=GAME_PAUSED;
             //sound effect
             Music escMusic = Gdx.audio.newMusic(Gdx.files.internal("ESC_sound.mp3"));
             escMusic.setVolume(2.5f);
@@ -104,45 +106,66 @@
             escMusic.play();
 
             //go to pause menu
+
             game.goToPauseMenu();
 
         }
+        if (Gdx.input.isKeyJustPressed(Input.Keys.V) | gameState == GAME_LEVEL_END) {
+            //Sound effect
+            Music escMusic = Gdx.audio.newMusic(Gdx.files.internal("ESC_sound.mp3"));
+            escMusic.setVolume(2.5f);
+            escMusic.setLooping(false);
+            escMusic.play();
+            //go to Victory Screen
+            game.goToVictoryScreen();
+
+        }
+        if (Gdx.input.isKeyJustPressed(Input.Keys.L) | gameState == GAME_OVER) {
+            //Sound effect
+            Music escMusic = Gdx.audio.newMusic(Gdx.files.internal("ESC_sound.mp3"));
+            escMusic.setVolume(2.5f);
+            escMusic.setLooping(false);
+            escMusic.play();
+            //go to Victory Screen
+            game.goToGameOverScreen();
+
+        }
 
         ScreenUtils.clear(0, 0, 0, 1); // Clear the screen
 
-        if (gameState == GAME_RUNNING) {
+        if(gameState==GAME_RUNNING) {
             renderMap();
             Player player = game.getGameEngine().getPlayer();
 
-            if (Gdx.input.isKeyPressed(Input.Keys.W) | Gdx.input.isKeyPressed(Input.Keys.UP)) {
-                if (isPlayerAtBarrier()) {
+            if (Gdx.input.isKeyPressed(Input.Keys.W)) {
+                if(isPlayerAtBarrier()){
                     player.setDirection(STANDINGUP);
                     renderStandingPlayer();
-                } else {
+                }else {
                     player.setDirection(UP);
                     renderPlayer();
                 }
-            } else if (Gdx.input.isKeyPressed(Input.Keys.S) | Gdx.input.isKeyPressed(Input.Keys.DOWN)) {
-                if (isPlayerAtBarrier()) {
+            } else if (Gdx.input.isKeyPressed(Input.Keys.S)) {
+                if(isPlayerAtBarrier()){
                     player.setDirection(STANDINGDOWN);
                     renderStandingPlayer();
-                } else {
+                }else {
                     player.setDirection(DOWN);
                     renderPlayer();
                 }
-            } else if (Gdx.input.isKeyPressed(Input.Keys.A) | Gdx.input.isKeyPressed(Input.Keys.LEFT)) {
-                if (isPlayerAtBarrier()) {
+            } else if (Gdx.input.isKeyPressed(Input.Keys.A)) {
+                if(isPlayerAtBarrier()){
                     player.setDirection(STANDINGLEFT);
                     renderStandingPlayer();
-                } else {
+                }else {
                     player.setDirection(LEFT);
                     renderPlayer();
                 }
-            } else if (Gdx.input.isKeyPressed(Input.Keys.D) | Gdx.input.isKeyPressed(Input.Keys.RIGHT)) {
-                if (isPlayerAtBarrier()) {
+            } else if (Gdx.input.isKeyPressed(Input.Keys.D)) {
+                if(isPlayerAtBarrier()){
                     player.setDirection(STANDINGRIGHT);
                     renderStandingPlayer();
-                } else {
+                }else {
                     player.setDirection(RIGHT);
                     renderPlayer();
                 }
@@ -151,13 +174,14 @@
                 renderStandingPlayer();
             }
 
-            //camera.update(); // Update the camera
 
-            if (isPlayerAtEdge() && !gameStart) {
+            if (isPlayerAtEdge()) {
                 System.out.println("Player at Edge; Updating Camera");
                 updateCameraPosition();
             }
 
+            //camera.update(); // Update the camera
+
             // Move text in a circular path to have an example of a moving object
             sinusInput += delta;
             float textX = (float) (camera.position.x + Math.sin(sinusInput) * 100);
@@ -166,12 +190,15 @@
             // Set up and begin drawing with the sprite batch
             game.getSpriteBatch().setProjectionMatrix(camera.combined);
 
+
             game.getSpriteBatch().begin(); // Important to call this before drawing anything
 
             game.getSpriteBatch().end(); // Important to call this after drawing everything
 
+
             camera.update(); // Update the camera
 
+
             // Move text in a circular path to have an example of a moving object
             sinusInput += delta;
             //float textX = (float) (camera.position.x + Math.sin(sinusInput) * 100);
@@ -180,64 +207,36 @@
             // Set up and begin drawing with the sprite batch
             game.getSpriteBatch().setProjectionMatrix(camera.combined);
 
+
             game.getSpriteBatch().begin(); // Important to call this before drawing anything
 
-        game.getSpriteBatch().end(); // Important to call this after drawing everything
+            game.getSpriteBatch().end(); // Important to call this after drawing everything
 
             player.setCurrentTileFromCoords(game.getGameEngine().getStaticGameMap(), tileSize);
 
-            for (Enemy enemy : game.getGameEngine().getStaticGameMap().getEnemies()) {
+            for(Enemy enemy: game.getGameEngine().getStaticGameMap().getEnemies()){
+                enemy.setWindowCordsFromTilet(tileSize);
                 renderEnemy(enemy);
-                if (isPlayerTouchingEnemy(enemy)) {
-                    gameState = GAME_OVER;
-                }
             }
 
-            if (player.getCurrentTile() instanceof Trap) {
+            if(player.getCurrentTile() instanceof Trap){
                 gameState = GAME_OVER;
             }
-            if (player.getCurrentTile() instanceof Exit && game.getGameEngine().getStaticGameMap().getKeysLeft() == 0) {
+            if (player.getCurrentTile() instanceof Exit && game.getGameEngine().getStaticGameMap().getKeysLeft() == 0){
                 gameState = GAME_LEVEL_END;
             }
 
-            if (player.getCurrentTile() instanceof Key) {
-                game.getGameEngine().getStaticGameMap().removeKey(player.getCurrentWindowX() + centerPlayerXOffset, player.getCurrentWindowY() + centerPlayerYOffset, tileSize);
+            if (player.getCurrentTile() instanceof Key){
+                game.getGameEngine().getStaticGameMap().removeKey(player.getCurrentWindowX() + centerPlayerXOffset, player.getCurrentWindowY()+ centerPlayerYOffset,  tileSize);
             }
-
         }
     }
-
-    private boolean isPlayerTouchingEnemy(Enemy enemy) {
-        Player player = game.getGameEngine().getPlayer();
-
-        float offsetVerticalTop = 5;
-        float offsetVerticalBottom = 33;
-        float offsetHorizontal = 30;
-        float centerEnemyXOffset = centerPlayerXOffset;
-        float centerEnemyYOffset = centerPlayerYOffset;
-
-        float playerCenterX = player.getCurrentWindowX() + centerPlayerXOffset;
-        float playerCenterY = player.getCurrentWindowY() + centerPlayerYOffset;
-
-        float enemyCenterX = enemy.getCurrentWindowX() + centerEnemyXOffset;
-        float enemyCenterY = enemy.getCurrentWindowY() + centerEnemyYOffset;
-
-        float deltaX = playerCenterX - enemyCenterX;
-        float deltaY = playerCenterY - enemyCenterY;
-
-        if (Math.abs(deltaX) < offsetHorizontal && Math.abs(deltaY) < offsetVerticalBottom) {
-            return true;
-        }
-        return false;
-    }
 
     // Render Map
     public void renderMap() {
         MapObject[][] mapObjects = game.getGameEngine().getStaticGameMap().getStaticMapObjects();
 
         // Calculate the size of each tile on the screen, for example:
-
-
         game.getSpriteBatch().begin();
 
         for (int row = 0; row < mapObjects.length; row++) {
@@ -283,7 +282,10 @@
 
         game.getSpriteBatch().begin();
         // Draw the standing frame scaled to tileSize
-        game.getSpriteBatch().draw(currentFrame, x, y, 64, 128 // Adjust the size as needed
+        game.getSpriteBatch().draw(
+                currentFrame,
+                x, y,
+                64, 128 // Adjust the size as needed
         );
         game.getSpriteBatch().end();
     }
@@ -312,7 +314,6 @@
                 renderPlayer();
                 return;
         }
-
         game.getSpriteBatch().begin();
         // Draw the standing frame scaled to tileSize
         game.getSpriteBatch().draw(
@@ -325,38 +326,6 @@
 
     private void renderEnemy(Enemy enemy) {
         Animation<TextureRegion> anim = null;
-        Player player = game.getGameEngine().getPlayer();
-        float x = player.getOffsetWindowX(tileSize, enemy.getPersonality());
-        float y = player.getOffsetWindowY(tileSize, enemy.getPersonality());
-
-        x = x - enemy.getCurrentWindowX();
-        y = y - enemy.getCurrentWindowY();
-
-        //Path Finding Algorythm
-        Direction direction;
-
-        if (x > 0) {
-            if (y > 0) {
-                direction = (x > y) ? RIGHT : UP;
-            } else {
-                direction = (Math.abs(x) > Math.abs(y)) ? RIGHT : DOWN;
-            }
-        } else {
-            if (y > 0) {
-                direction = (Math.abs(x) > y) ? LEFT : UP;
-            } else {
-                direction = (Math.abs(x) > Math.abs(y)) ? LEFT : DOWN;
-            }
-        }
-        if (enemy.getMovementSmoothing() == 0) {
-            enemy.setDirection(direction);
-        } else if (isEnemyAtBarrier(enemy)) {
-            enemy.rotateDirection();
-        }
-
-        enemy.decrmenentMovementSmoothing();
-        //enemy.setDirection(direction);
-        enemy.move(enemySpeed);
         switch (enemy.getDirection()) {
             case UP -> anim = enemy.getCharacterUpAnimation();
             case DOWN -> anim = enemy.getCharacterDownAnimation();
@@ -374,30 +343,28 @@
         game.getSpriteBatch().draw(currentFrame, enemy.getCurrentWindowX(), enemy.getCurrentWindowY(), 64, 128);
         game.getSpriteBatch().end();
 
-        //enemy.setDirection(getStandingDirection(enemy.getDirection()));
+        enemy.setDirection(getStandingDirection(enemy.getDirection()));
     }
 
     private void renderPlayer() {
         float projectionPlaneHeight = camera.viewportHeight / camera.zoom;
-        float projectionPlaneWidth = game.getGameEngine().getStaticGameMap().getMapWidth() * tileSize;//camera.viewportWidth / camera.zoom;
+        float projectionPlaneWidth = game.getGameEngine().getStaticGameMap().getMapWidth()*tileSize;//camera.viewportWidth / camera.zoom;
         Player player = game.getGameEngine().getPlayer();
         player.move(playerSpeed);
         float x = player.getCurrentWindowX();
         float y = player.getCurrentWindowY();
 
-        /*
-        if (x < 0) {
+        if(x < 0){
             player.setCurrentWindowX(0);
-        } else if (y < 0) {
+        } else if (y < 0 ) {
             player.setCurrentWindowY(0);
-        } else if (x + tileSize > projectionPlaneWidth) {
-            System.out.println("Player at Right Part of the Map " + player.getCurrentWindowX() + " " + player.getCurrentWindowY() + " proejctionPlanteWidth: " + projectionPlaneWidth);
-            player.setCurrentWindowX(projectionPlaneWidth - tileSize);
-        } else if (y - tileSize > projectionPlaneHeight) {
-            System.out.println("Player at Top Part of the Map " + player.getCurrentWindowX() + " " + player.getCurrentWindowY() + " proejctionPlanteHeight: " + projectionPlaneHeight);
-            player.setCurrentWindowY(projectionPlaneHeight + tileSize);
+        } else if (x+tileSize > projectionPlaneWidth) {
+            System.out.println("Player at Right Part of the Map "+ player.getCurrentWindowX()+" "+player.getCurrentWindowY()+ " proejctionPlanteWidth: "+projectionPlaneWidth);
+            player.setCurrentWindowX(projectionPlaneWidth-tileSize);
+        } else if (y-tileSize > projectionPlaneHeight) {
+            System.out.println("Player at Top Part of the Map "+ player.getCurrentWindowX()+" "+player.getCurrentWindowY()+ " proejctionPlanteHeight: "+projectionPlaneHeight);
+            player.setCurrentWindowY(projectionPlaneHeight+tileSize);
         }
-         */
 
         Animation<TextureRegion> anim = null;
 
@@ -406,6 +373,10 @@
             case DOWN -> anim = player.getCharacterDownAnimation();
             case LEFT -> anim = player.getCharacterLeftAnimation();
             case RIGHT -> anim = player.getCharacterRightAnimation();
+            default -> {
+                renderStandingPlayer();
+                return;
+            }
         }
 
         TextureRegion currentFrame = anim.getKeyFrame(sinusInput, true);
@@ -416,10 +387,10 @@
 
         player.setDirection(getStandingDirection(player.getDirection()));
     }
-
-    private boolean isPlayerAtBarrier() {
+    private boolean isPlayerAtBarrier(){
         Player player = game.getGameEngine().getPlayer();
 
+
         float offsetVerticalTop = 5;
         float offsetVerticalBottom = 33;
         float offsetHorizontal = 30;
@@ -430,21 +401,21 @@
         switch (player.getDirection()) {
             case STANDINGLEFT:
             case LEFT:
-                if (game.getGameEngine().getStaticGameMap().getTile(playerCenterX - offsetHorizontal, playerCenterY, tileSize) instanceof Wall) {
+                if(game.getGameEngine().getStaticGameMap().getTile(playerCenterX - offsetHorizontal, playerCenterY, tileSize) instanceof Wall){
                     System.out.println("Player On Wall");
                     return true;
                 }
-                break;
+            break;
             case STANDINGRIGHT:
             case RIGHT:
-                if (game.getGameEngine().getStaticGameMap().getTile(playerCenterX + offsetHorizontal, playerCenterY, tileSize) instanceof Wall) {
+                if(game.getGameEngine().getStaticGameMap().getTile(playerCenterX + offsetHorizontal, playerCenterY, tileSize) instanceof Wall){
                     System.out.println("Player On Wall");
                     return true;
                 }
                 break;
             case STANDINGUP:
             case UP:
-                if (game.getGameEngine().getStaticGameMap().getTile(playerCenterX, playerCenterY + offsetVerticalTop, tileSize) instanceof Wall) {
+                if(game.getGameEngine().getStaticGameMap().getTile(playerCenterX, playerCenterY + offsetVerticalTop, tileSize) instanceof Wall){
                     System.out.println("Player On Wall");
                     return true;
                 }
@@ -452,7 +423,7 @@
 
             case STANDINGDOWN:
             case DOWN:
-                if (game.getGameEngine().getStaticGameMap().getTile(playerCenterX, playerCenterY - offsetVerticalBottom, tileSize) instanceof Wall) {
+                if(game.getGameEngine().getStaticGameMap().getTile(playerCenterX, playerCenterY - offsetVerticalBottom, tileSize) instanceof Wall){
                     System.out.println("Player On Wall");
                     return true;
                 }
@@ -460,51 +431,13 @@
         }
         return false;
     }
-
-    private boolean isEnemyAtBarrier(Enemy enemy) {
-        float offsetVerticalTop = 5;
-        float offsetVerticalBottom = 33;
-        float offsetHorizontal = 30;
-
-        float playerCenterX = enemy.getCurrentWindowX() + centerPlayerXOffset;
-        float playerCenterY = enemy.getCurrentWindowY() + centerPlayerYOffset;
-
-        switch (enemy.getDirection()) {
-            case STANDINGLEFT:
-            case LEFT:
-                if (game.getGameEngine().getStaticGameMap().getTile(playerCenterX - offsetHorizontal, playerCenterY, tileSize) instanceof Wall) {
-                    return true;
-                }
-                break;
-            case STANDINGRIGHT:
-            case RIGHT:
-                if (game.getGameEngine().getStaticGameMap().getTile(playerCenterX + offsetHorizontal, playerCenterY, tileSize) instanceof Wall) {
-                    return true;
-                }
-                break;
-            case STANDINGUP:
-            case UP:
-                if (game.getGameEngine().getStaticGameMap().getTile(playerCenterX, playerCenterY + offsetVerticalTop, tileSize) instanceof Wall) {
-                    return true;
-                }
-                break;
-
-            case STANDINGDOWN:
-            case DOWN:
-                if (game.getGameEngine().getStaticGameMap().getTile(playerCenterX, playerCenterY - offsetVerticalBottom, tileSize) instanceof Wall) {
-                    return true;
-                }
-                break;
-        }
-        return false;
-    }
 
     private Direction getStandingDirection(Direction currentDirection) {
         return switch (currentDirection) {
-            case UP -> Direction.STANDINGUP;
-            case DOWN -> Direction.STANDINGDOWN;
-            case LEFT -> Direction.STANDINGLEFT;
-            case RIGHT -> Direction.STANDINGRIGHT;
+            case UP -> STANDINGUP;
+            case DOWN -> STANDINGDOWN;
+            case LEFT -> STANDINGLEFT;
+            case RIGHT -> STANDINGRIGHT;
             // For standing directions, keep the same
             default -> currentDirection;
         };
@@ -515,17 +448,29 @@
         float playerX = player.getCurrentWindowX();
         float playerY = player.getCurrentWindowY();
 
+        float edge = 0.2f;
+
+        //.out.println("Camera Coords x/y:"+camera.position.x+ " "+ camera.position.y);
+        //System.out.println("Camera Viewport w/h"+camera.viewportWidth +" "+camera.viewportHeight);
+        //System.out.println("PlayerCoords x/y "+playerX + " "+playerY);
+
+        //System.out.println("Left Bound "+(camera.position.x - 0.5 * camera.viewportWidth));
+        //System.out.println("Right Bound "+(camera.position.x + 0.5 * camera.viewportWidth));
         // Check left and right bounds
+
         if (playerX < camera.position.x - 0.3 * camera.viewportWidth) {
             return true;
         } else if (playerX > camera.position.x + 0.3 * camera.viewportWidth) {
             return true;
         }
 
+        //System.out.println("Top Bound "+(camera.position.y + 0.5 * camera.viewportHeight));
+        //System.out.println("Bottom Bound "+(camera.position.y - 0.5 * camera.viewportHeight));
+
         // Check top and bottom bounds
-        if (playerY < camera.position.y - 0.25 * camera.viewportHeight) {
+        if (playerY < camera.position.y - 0.25 * camera.viewportHeight)  {
             return true;
-        } else if (playerY > camera.position.y + 0.25 * camera.viewportHeight) {
+        } else if (playerY  > camera.position.y + 0.25 * camera.viewportHeight ) {
             return true;
         }
 
@@ -537,53 +482,51 @@
         float screenWidth = camera.viewportWidth;
         float screenHeight = camera.viewportHeight;
         // Define how close to the edge the player must be to move the camera
-        System.out.println("Screen Height: " + screenHeight);
+        System.out.println("Screen Height: "+screenHeight);
         System.out.println("Snap");
-
         // Check and update camera position based on player's direction
         switch (player.getDirection()) {
             case UP:
             case STANDINGUP:
-                camera.position.y += screenHeight * 0.5; // Move camera up by one screen height
+                camera.position.y += screenHeight*0.5; // Move camera up by one screen height
                 break;
             case DOWN:
             case STANDINGDOWN:
-                camera.position.y -= screenHeight * 0.5; // Move camera down by one screen height
+                    camera.position.y -= screenHeight*0.5; // Move camera down by one screen height
                 System.out.println("Set camera to: " + camera.position.y);
                 break;
             case LEFT:
             case STANDINGLEFT:
-                camera.position.x -= screenWidth * 0.5; // Move camera left by one screen width
+                    camera.position.x -= screenWidth*0.5; // Move camera left by one screen width
                 System.out.println("Set camera to: " + camera.position.x);
                 break;
             case RIGHT:
             case STANDINGRIGHT:
-                camera.position.x += screenWidth * 0.5; // Move camera right by one screen width
+                    camera.position.x += screenWidth*0.5; // Move camera right by one screen width
                 System.out.println("Set camera to: " + camera.position.x);
                 break;
         }
 
-        float projectionPlaneHeight = game.getGameEngine().getStaticGameMap().getMapHeight() * tileSize;
-        float projectionPlaneWidth = game.getGameEngine().getStaticGameMap().getMapWidth() * tileSize;//camera.viewportWidth / camera.zoom;
+        float projectionPlaneHeight = camera.viewportHeight / camera.zoom;
+        float projectionPlaneWidth = game.getGameEngine().getStaticGameMap().getMapWidth()*tileSize;//camera.viewportWidth / camera.zoom;
 
-        if (camera.position.y > projectionPlaneHeight) {
+        if(camera.position.y > projectionPlaneHeight){
             camera.position.y = projectionPlaneHeight;
-            System.out.println("Changed Y-position due to camera out of map-bounds" + camera.position.y);
+            System.out.println("Changed position due to camera out of map-bounds"+camera.position.y);
         }
-        if (camera.position.y < 0) {
+        if(camera.position.y < 0){
             camera.position.y = 0;
-            System.out.println("Changed Y-position due to camera out of map-bounds" + camera.position.y);
+            System.out.println("Changed position due to camera out of map-bounds"+camera.position.y);
         }
-        if (camera.position.x < 0) {
+        if(camera.position.x < 0){
             camera.position.x = 0;
-            System.out.println("Changed X-position due to camera out of map-bounds" + camera.position.x);
+            System.out.println("Changed position due to camera out of map-bounds"+camera.position.x);
         }
 
-        if (camera.position.x > projectionPlaneWidth) {
+        if(camera.position.x > projectionPlaneWidth){
             camera.position.x = projectionPlaneWidth;
-            System.out.println("Changed X-position due to camera out of map-bounds" + camera.position.x);
+            System.out.println("Changed position due to camera out of map-bounds"+camera.position.x);
         }
-
         camera.update(); // Update the camera after repositioning
     }
 
Index: core/src/de/tum/cit/ase/maze/MenuScreen.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/MenuScreen.java b/core/src/de/tum/cit/ase/maze/MenuScreen.java
--- a/core/src/de/tum/cit/ase/maze/MenuScreen.java	
+++ b/core/src/de/tum/cit/ase/maze/MenuScreen.java	(date 1704667156625)
@@ -5,13 +5,18 @@
 import com.badlogic.gdx.audio.Music;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.OrthographicCamera;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.actions.Actions;
+import com.badlogic.gdx.scenes.scene2d.ui.Image;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Table;
 import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
 import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
+import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
+import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.viewport.ScreenViewport;
 import com.badlogic.gdx.utils.viewport.Viewport;
 
@@ -22,6 +27,7 @@
 public class MenuScreen implements Screen {
 
     private final Stage stage;
+    private float elapsedTime = 2f;
 
     /**
      * Constructor for MenuScreen. Sets up the camera, viewport, stage, and UI elements.
@@ -39,12 +45,16 @@
         table.setFillParent(true); // Make the table fill the stage
         stage.addActor(table); // Add the table to the stage
 
+        Image fireImage = createFireAnimation();
+        table.add(fireImage).padBottom(100).row();
+
         // Add a label as a title
         table.add(new Label("Welcome to Maze Runner Game!", game.getSkin(), "title")).padBottom(80).row();
 
         // Create and add a button to go to the game screen
         TextButton goToGameButton = new TextButton("Go To Game", game.getSkin());
         table.add(goToGameButton).width(300).row();
+        // Add sound effect to the button
         goToGameButton.addListener(new ChangeListener() {
             @Override
             public void changed(ChangeEvent event, Actor actor) {
@@ -57,6 +67,40 @@
         });
     }
 
+    // Create an animation for the skull
+    private Image createFireAnimation() {
+        Array<TextureRegion> fireFrames = new Array<>();
+        Texture skullSheet = new Texture(Gdx.files.internal("things.png"));
+        int frameWidth = 16;
+        int frameHeight = 16;
+        int animationFramesRow = 3;
+
+        for (int i = 0; i < animationFramesRow; i++) {
+            fireFrames.add(new TextureRegion(skullSheet, 144+ i * frameWidth, 64, frameWidth, frameHeight));
+        }
+
+        Image fireImage = new Image(fireFrames.get(0));
+        fireImage.setOrigin(fireImage.getWidth() / 2, fireImage.getHeight() / 2);
+        fireImage.setSize(100, 100);
+        fireImage.setScale(10f);
+
+        var skullAnimation = Actions.forever(
+                Actions.sequence(
+                        Actions.run(() -> {
+                            int frameIndex = (int) (elapsedTime / 0.03333f) % fireFrames.size;
+                            fireImage.setDrawable(new TextureRegionDrawable(fireFrames.get(frameIndex)));
+                            elapsedTime += Gdx.graphics.getDeltaTime();
+                        }),
+                        Actions.delay(0.1f)
+                )
+        );
+
+        fireImage.addAction(skullAnimation);
+        return fireImage;
+    }
+
+
+
     @Override
     public void render(float delta) {
         Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); // Clear the screen
Index: core/src/de/tum/cit/ase/maze/MazeRunnerGame.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/MazeRunnerGame.java b/core/src/de/tum/cit/ase/maze/MazeRunnerGame.java
--- a/core/src/de/tum/cit/ase/maze/MazeRunnerGame.java	
+++ b/core/src/de/tum/cit/ase/maze/MazeRunnerGame.java	(date 1704667156622)
@@ -1,42 +1,39 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by FernFlower decompiler)
+//
+
 package de.tum.cit.ase.maze;
 
 import com.badlogic.gdx.Game;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.audio.Music;
-import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.g2d.Animation;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
-import com.badlogic.gdx.utils.Array;
 import games.spooky.gdx.nativefilechooser.NativeFileChooser;
-import com.badlogic.gdx.utils.Json;
-import com.badlogic.gdx.files.FileHandle;
 
-/**
- * The MazeRunnerGame class represents the core of the Maze Runner game.
- * It manages the screens and global resources like SpriteBatch and Skin.
- */
 public class MazeRunnerGame extends Game {
-    // Screens
     private MenuScreen menuScreen;
     private PauseMenuScreen pauseMenuScreen;
-    private GameScreen gameScreen;
+
+
 
     // Sprite Batch for rendering
     private SpriteBatch spriteBatch;
-
-    // UI Skin
     private Skin skin;
+    // Music
+    private Music backGroundMusic;
+    private  GameEngine gameEngine;
 
 
 
     // Character animation downwards
     private Animation<TextureRegion> characterDownAnimation;
 
-    // Getter methods
     public Skin getSkin() {
-        return skin;
+        return this.skin;
     }
 
     public Animation<TextureRegion> getCharacterDownAnimation() {
@@ -44,12 +41,11 @@
     }
 
     public SpriteBatch getSpriteBatch() {
-        return spriteBatch;
+        return this.spriteBatch;
     }
-
 
     public GameEngine getGameEngine() {
-        return gameEngine;
+        return this.gameEngine;
     }
 
 
@@ -68,110 +64,119 @@
     //JODIE TRYING OUT THINGS
 
 
+    public Music getBackgroundMusic() {
+        return backGroundMusic;
+    }
 
-    // Engine
-    private  GameEngine gameEngine;
-    private static final String GAME_STATE_FILE_PATH = "game_state.json";
+    public void setMenuScreen(MenuScreen menuScreen) {
+        this.menuScreen = menuScreen;
+    }
 
+    public void setSelectScreen(SelectScreen selectScreen) {
+        this.selectScreen = selectScreen;
+    }
 
-
-    /**
-     * Constructor for MazeRunnerGame.
-     *
-     * @param fileChooser The file chooser for the game, typically used in desktop environment.
-     */
     public MazeRunnerGame(NativeFileChooser fileChooser) {
-        super();
     }
 
-    /**
-     * Called when the game is created. Initializes the SpriteBatch and Skin.
-     */
-    @Override
     public void create() {
         spriteBatch = new SpriteBatch(); // Create SpriteBatch
         skin = new Skin(Gdx.files.internal("craft/craftacular-ui.json")); // Load UI skin
 
         // Play some background music
         // Background sound
-        this.backgroundMusic = Gdx.audio.newMusic(Gdx.files.internal("crystal_cave.mp3"));
-        backgroundMusic.setVolume(0.5f);
-        backgroundMusic.setLooping(true);
-        backgroundMusic.play();
+        this.backGroundMusic = Gdx.audio.newMusic(Gdx.files.internal("crystal_cave.mp3"));
+        backGroundMusic.setVolume(0.5f);
+        backGroundMusic.setLooping(true);
+        backGroundMusic.play();
 
         // Load Engine and Map
         gameEngine = new GameEngine();
 
         goToMenu(); // Navigate to the menu screen
-    }
 
-    /**
-     * Cleans up resources when the game is disposed.
-     */
-    @Override
-    public void dispose() {
-        getScreen().hide(); // Hide the current screen
-        getScreen().dispose(); // Dispose the current screen
-        spriteBatch.dispose(); // Dispose the spriteBatch
-        skin.dispose(); // Dispose the skin
-        backgroundMusic.dispose();
     }
 
-    /**
-     * Switches to the menu screen.
-     */
+
     public void goToMenu() {
-        this.setScreen(new MenuScreen(this)); // Set the current screen to MenuScreen
+        this.menuScreen = new MenuScreen(this);
+        this.setScreen(this.menuScreen);
+        if (this.gameScreen != null) {
+            this.gameScreen.dispose();
+            this.gameScreen = null;
+        }
+
+    }
+    /**
+     * Switches to the pause menu screen when press ESC.
+     */
+
+    public void goToPauseMenu(){
+
+        this.setScreen(new PauseMenuScreen(this)); // Set the current screen to MenuScreen
+        this.pause();
+    }
+
+
+    /**
+     * Switches to the Victory or Game Over screen when win or lose the game.
+     */
+
+    public void goToVictoryScreen(){
+        //this.setScreen(new FireScreen());  // Testing
+        this.setScreen(new VictoryScreen(this)); // Set the current screen to MenuScreen
+
         if (gameScreen != null) {
             gameScreen.dispose(); // Dispose the game screen if it exists
             gameScreen = null;
         }
+
     }
-    /**
-     * Switches to the pause menu screen when press ESC.
-     */
-    public void goToPauseMenu(){
 
-        this.setScreen(new PauseMenuScreen(this)); // Set the current screen to MenuScreen
+    public void goToGameOverScreen(){
+        //this.setScreen(new FireScreen());  // Testing
+        this.setScreen(new GameOverScreen(this)); // Set the current screen to MenuScreen
+
         if (gameScreen != null) {
             gameScreen.dispose(); // Dispose the game screen if it exists
             gameScreen = null;
         }
     }
-    /* game resume function for continue game button WIP
-    public void resumeGame() {
-
-        this.getSkin();
-        this.getSpriteBatch();
-        this.getCharacterDownAnimation();
-        this.setScreen(getGameScreen());
-        this.render();
-        // Set the current screen to GameScreen
-        if ( pauseMenuScreen!= null) {
-            pauseMenuScreen.dispose(); // Dispose the game screen if it exists
-            pauseMenuScreen = null;
-        }
-
-    }*/
 
 
     /**
      * Switches to the game screen.
      */
+
     public void goToGame() {
         this.setScreen(new GameScreen(this)); // Set the current screen to GameScreen
+
         if (menuScreen != null) {
             menuScreen.dispose(); // Dispose the menu screen if it exists
             menuScreen = null;
         }
-    }
-
-
-
-
 
+    }
 
+    public void continueGame(){
+       // this.setScreen(getGameScreen());// Set the current screen to GameScreen
+        this.setScreen(gameScreen);
+        if (pauseMenuScreen != null) {
+            pauseMenuScreen.dispose(); // Dispose the menu screen if it exists
+            pauseMenuScreen = null;
+        }
+    }
 
+    /**
+     * Cleans up resources when the game is disposed.
+     */
+    @Override
+    public void dispose() {
+        getScreen().hide(); // Hide the current screen
+        getScreen().dispose(); // Dispose the current screen
+        spriteBatch.dispose(); // Dispose the spriteBatch
+        skin.dispose(); // Dispose the skin
+        backGroundMusic.dispose();
 
-
+    }
 }
Index: core/src/de/tum/cit/ase/maze/PauseMenuScreen.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/PauseMenuScreen.java b/core/src/de/tum/cit/ase/maze/PauseMenuScreen.java
--- a/core/src/de/tum/cit/ase/maze/PauseMenuScreen.java	
+++ b/core/src/de/tum/cit/ase/maze/PauseMenuScreen.java	(date 1704667156613)
@@ -83,10 +83,7 @@
                                 // Dispose of the current game and create a new one
                                 game.dispose();
                                 game.create();
-                                // You can add more animation effects here if needed
-
-                                // Switch to the game menu
-                                game.goToMenu();
+                                game.goToSelect();
                             }
                         })
                 ));
@@ -165,6 +162,7 @@
 
     public void resume(){
 
+
     }
 
 
diff --git a/core/src/de/tum/cit/ase/maze/GameScreen_hide_flow.puml b/core/src/de/tum/cit/ase/maze/GameScreen_hide_flow.puml
new file mode 100644
diff --git a/core/src/de/tum/cit/ase/maze/GameScreen_show_flow.puml b/core/src/de/tum/cit/ase/maze/GameScreen_show_flow.puml
new file mode 100644
diff --git a/core/src/de/tum/cit/ase/maze/GameScreen_pause_flow.puml b/core/src/de/tum/cit/ase/maze/GameScreen_pause_flow.puml
new file mode 100644
diff --git a/core/src/de/tum/cit/ase/maze/GameScreen_render_flow.puml b/core/src/de/tum/cit/ase/maze/GameScreen_render_flow.puml
new file mode 100644
diff --git a/core/src/de/tum/cit/ase/maze/GameScreen_resize_flow.puml b/core/src/de/tum/cit/ase/maze/GameScreen_resize_flow.puml
new file mode 100644
diff --git a/core/src/de/tum/cit/ase/maze/GameScreen_resume_flow.puml b/core/src/de/tum/cit/ase/maze/GameScreen_resume_flow.puml
new file mode 100644
diff --git a/core/src/de/tum/cit/ase/maze/GameScreen_dispose_flow.puml b/core/src/de/tum/cit/ase/maze/GameScreen_dispose_flow.puml
new file mode 100644
